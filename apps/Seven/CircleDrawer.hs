{-# LANGUAGE BlockArguments        #-}
{-# LANGUAGE DerivingStrategies    #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE LambdaCase            #-}
{-# LANGUAGE MonadComprehensions   #-}
{-# LANGUAGE OverloadedLists       #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE RecursiveDo           #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TupleSections         #-}
module Seven.CircleDrawer where

import           Seven.Attributes   (ToAttributes (..))
import           Seven.Dialog       (ModalState (..), dialog)
import           Seven.Element
import           Seven.Event
import qualified Seven.PushMap      as PushMap
import           Seven.SVG
import           Seven.Widget

import           Control.Lens       (element, (<&>), (??))
import           Control.Monad      (join, void)

import           Data.Bool          (bool)
import qualified Data.ByteString    as BS
import           Data.Default.Class (def)
import           Data.Map           (Map)
import qualified Data.Map           as Map
import           Data.Maybe         (fromMaybe)
import           Data.Text          (Text)
import           Data.Text.Display  (Display)

import           Reflex
import qualified Reflex.Dom         as Dom

import           Witherable         (Filterable (..), catMaybes)

widget :: forall m t. Dom t m => m ()
widget = Dom.elClass "div" "circle-drawer" do
  action <- Dom.elClass "div" "centered controls" do
    undos <- Dom.button "↶"
    redos <- Dom.button "↷"
    pure $ leftmost [undos, redos]

  Dom.elClass "div" "canvas" do
    rec let clicks = Witherable.filter isMain $ Dom.domEvent Dom.Click canvas
            isMain e = button e == Main
        circles <- foldDyn pushCircle mempty clicks
        (canvas, (selected, clicked)) <- svg' "svg" do
          let justAdded = updated $ PushMap.maxKey <$> circles
          (selectedFromSvg, clicked) <-
            fanCircle <$> selectView selected circles (withId svgCircle)

          selected <- holdDyn Nothing $ leftmost [justAdded, selectedFromSvg]
          pure (selected, clicked)

    let getClicked circles i = join $ (PushMap.lookup <$> i) ?? circles
    clickedI <- holdDyn Nothing $ Just <$> clicked
    let clickedCircle = zipDynWith getClicked circles clickedI
    void $ dialog (ShowModal <$ clicked) (constDyn []) do
      output clickedCircle
  where pushCircle MouseEventResult { offset = (x, y) } =
          PushMap.push Circle { center = (fromIntegral x, fromIntegral y), radius = 50 }

        withId :: (Dynamic t a -> Dynamic t Bool -> m (Event t b))
               -> (Int -> Dynamic t a -> Dynamic t Bool -> m (Event t (b, Int)))
        withId f i value selected = do
          event <- f value selected
          pure $ (,i) <$> event

        fanCircle events = (mapMaybe overOut events, mapMaybe click events)
        overOut = \case
          (Over, i)  -> Just (Just i)
          (Out, _)   -> Just Nothing
          (Click, _) -> Nothing
        click = \case
          (Click, i) -> Just i
          _          -> Nothing


-- | Render an SVG circle.
--
-- The 'Event' returned will trigger when the mouse is moved over the
-- element or the element is clicked.
svgCircle :: forall m t. Dom t m
          => Dynamic t Circle
          -> Dynamic t Bool
          -> m (Event t CircleEvent)
svgCircle c isSelected = do
  element   <- circle c $ withDefaults <$> fillSelect
  isHovered <- hovering True element
  let hover = updated $ isHovered <&> bool Out Over
      isAuxiliary e = button e == Auxiliary
      click = Click <$ Witherable.filter isAuxiliary (Dom.domEvent Dom.Click element)
  pure $ leftmost [click, hover]
  where fillSelect = bool [("fill", "#fff0")] [("fill", "gray")] <$> isSelected
        withDefaults = (<> toAttributes def { width = 2 })

-- | Events to track on circles generated by the user.
data CircleEvent = Over
                 -- ^ The mouse moved over the circle
                 | Out
                 -- ^ The mouse moved out of the circle
                 | Click
                 -- ^ The user clicked on the circle
  deriving stock (Show, Eq, Ord, Enum, Bounded)

main :: IO ()
main = do
  css <- BS.readFile "css/tasks.css"
  Dom.mainWidgetWithCss css widget
